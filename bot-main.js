const TelegramBot = require('node-telegram-bot-api');
const { createClient } = require('@supabase/supabase-js');
require('dotenv').config();

console.log('üöÄ Iniciando bot de Telegram...');
console.log('üìã Variables de entorno:');
console.log('- TELEGRAM_BOT_TOKEN:', process.env.TELEGRAM_BOT_TOKEN ? 'SET' : 'NOT SET');
console.log('- SUPABASE_URL:', process.env.NEXT_PUBLIC_SUPABASE_URL ? 'SET' : 'NOT SET');
console.log('- SUPABASE_ANON_KEY:', process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY ? 'SET' : 'NOT SET');

// Configuraci√≥n de Supabase
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  console.error('‚ùå Error: Variables de Supabase no configuradas');
  process.exit(1);
}

const supabase = createClient(supabaseUrl, supabaseAnonKey);
console.log('‚úÖ Cliente de Supabase creado');

// Configuraci√≥n del bot
const token = process.env.TELEGRAM_BOT_TOKEN;

if (!token) {
  console.error('‚ùå Error: TELEGRAM_BOT_TOKEN no configurado');
  process.exit(1);
}

console.log('ü§ñ Creando bot de Telegram...');
const bot = new TelegramBot(token, { polling: true });

console.log('‚úÖ Bot iniciado correctamente!');

// Estado del usuario para conversaciones
const userStates = {};

// Categor√≠as
const categories = {
  income: [
    { id: "salary", name: "üíº Salario" },
    { id: "freelance", name: "üíª Freelance" },
    { id: "other-income", name: "üí∞ Otros ingresos" },
  ],
  expense: [
    { id: "housing", name: "üè† Vivienda" },
    { id: "transport", name: "üöó Transporte" },
    { id: "food", name: "üçï Alimentaci√≥n" },
    { id: "entertainment", name: "üé¨ Entretenimiento" },
    { id: "health", name: "üíä Salud" },
    { id: "hobbies", name: "üéÆ Hobbies" },
    { id: "other", name: "üì¶ Otros" },
  ],
};

// Funciones de base de datos
async function getCouples() {
  const { data, error } = await supabase
    .from('couples')
    .select('*')
    .order('created_at', { ascending: false });

  if (error) {
    console.error('Error fetching couples:', error);
    return [];
  }

  return data || [];
}

async function getTransactions(coupleId) {
  const { data, error } = await supabase
    .from('transactions')
    .select('*')
    .eq('couple_id', coupleId)
    .order('transaction_date', { ascending: false });

  if (error) {
    console.error('Error fetching transactions:', error);
    return [];
  }

  return data || [];
}

async function addTransaction(transaction) {
  const { data, error } = await supabase
    .from('transactions')
    .insert([transaction])
    .select()
    .single();

  if (error) {
    console.error('Error adding transaction:', error);
    return null;
  }

  return data;
}

async function deleteTransaction(id) {
  const { error } = await supabase
    .from('transactions')
    .delete()
    .eq('id', id);

  if (error) {
    console.error('Error deleting transaction:', error);
    return false;
  }

  return true;
}

// Utilidades
function formatCurrency(amount) {
  return new Intl.NumberFormat("es-CO", {
    style: "currency",
    currency: "COP",
    minimumFractionDigits: 0,
  }).format(amount);
}

function getCategoryName(categoryId, type) {
  const categoryList = categories[type];
  const category = categoryList.find((c) => c.id === categoryId);
  return category ? category.name : "Otros";
}

// Comandos del bot
bot.onText(/\/start/, async (msg) => {
  const chatId = msg.chat.id;
  
  const welcomeMessage = `
ü§ñ ¬°Hola! Soy tu asistente financiero de DuoProfits

üìù Comandos disponibles:
‚Ä¢ /balance - Ver balance general
‚Ä¢ /transacciones - Ver √∫ltimas transacciones
‚Ä¢ /agregar - Agregar nueva transacci√≥n
‚Ä¢ /ayuda - Ver todos los comandos

üí° ¬°Empecemos a gestionar tus finanzas!
  `;

  await bot.sendMessage(chatId, welcomeMessage);
});

bot.onText(/\/ayuda/, async (msg) => {
  const chatId = msg.chat.id;
  
  const helpMessage = `
üìã Comandos disponibles:

üí∞ **CONSULTAS:**
‚Ä¢ /balance - Ver balance general
‚Ä¢ /transacciones - Ver √∫ltimas transacciones

‚ûï **GESTI√ìN:**
‚Ä¢ /agregar - Agregar nueva transacci√≥n
‚Ä¢ /eliminar - Eliminar transacci√≥n

üîß **UTILIDADES:**
‚Ä¢ /ayuda - Ver este mensaje
‚Ä¢ /cancelar - Cancelar operaci√≥n actual

üí° **Ejemplo de uso:**
1. Env√≠a /agregar
2. Sigue las instrucciones paso a paso
3. ¬°Listo! Tu transacci√≥n se guardar√° autom√°ticamente
  `;

  await bot.sendMessage(chatId, helpMessage);
});

bot.onText(/\/balance/, async (msg) => {
  const chatId = msg.chat.id;
  
  try {
    const couples = await getCouples();
    if (couples.length === 0) {
      await bot.sendMessage(chatId, "‚ùå No se encontraron datos de parejas.");
      return;
    }

    const couple = couples[0];
    const transactions = await getTransactions(couple.id);

    const totalIncome = transactions
      .filter(t => t.type === "income")
      .reduce((sum, t) => sum + t.amount, 0);

    const totalExpenses = transactions
      .filter(t => t.type === "expense")
      .reduce((sum, t) => sum + t.amount, 0);

    const balance = totalIncome - totalExpenses;

    const balanceMessage = `
üí∞ **BALANCE GENERAL - ${couple.name}**

üìà **Ingresos:** ${formatCurrency(totalIncome)}
üìâ **Gastos:** ${formatCurrency(totalExpenses)}
üíµ **Balance:** ${formatCurrency(balance)}

üìä **Total de transacciones:** ${transactions.length}

${balance >= 0 ? '‚úÖ ¬°Vas bien!' : '‚ö†Ô∏è Cuidado con los gastos'}
    `;

    await bot.sendMessage(chatId, balanceMessage, { parse_mode: 'Markdown' });
  } catch (error) {
    console.error('Error getting balance:', error);
    await bot.sendMessage(chatId, "‚ùå Error al obtener el balance. Int√©ntalo de nuevo.");
  }
});

bot.onText(/\/transacciones/, async (msg) => {
  const chatId = msg.chat.id;
  
  try {
    const couples = await getCouples();
    if (couples.length === 0) {
      await bot.sendMessage(chatId, "‚ùå No se encontraron datos de parejas.");
      return;
    }

    const couple = couples[0];
    const transactions = await getTransactions(couple.id);

    if (transactions.length === 0) {
      await bot.sendMessage(chatId, "üìù No hay transacciones registradas a√∫n.");
      return;
    }

    const recentTransactions = transactions.slice(0, 10);
    let message = `üìä **√öLTIMAS TRANSACCIONES**\n\n`;

    recentTransactions.forEach((transaction, index) => {
      const icon = transaction.type === "income" ? "üí∞" : "üí∏";
      const sign = transaction.type === "income" ? "+" : "-";
      const person = transaction.person === "person1" ? couple.person1_name : couple.person2_name;
      const category = getCategoryName(transaction.category, transaction.type);
      const date = new Date(transaction.transaction_date).toLocaleDateString('es-ES');

      message += `${icon} **${transaction.description}**\n`;
      message += `   ${sign}${formatCurrency(transaction.amount)}\n`;
      message += `   ${category} ‚Ä¢ ${person} ‚Ä¢ ${date}\n`;
      message += `   ID: \`${transaction.id}\`\n\n`;
    });

    if (transactions.length > 10) {
      message += `\nüìã Mostrando las 10 m√°s recientes de ${transactions.length} transacciones.`;
    }

    await bot.sendMessage(chatId, message, { parse_mode: 'Markdown' });
  } catch (error) {
    console.error('Error getting transactions:', error);
    await bot.sendMessage(chatId, "‚ùå Error al obtener las transacciones. Int√©ntalo de nuevo.");
  }
});

bot.onText(/\/agregar/, async (msg) => {
  const chatId = msg.chat.id;
  
  // Inicializar el estado del usuario
  userStates[chatId] = {
    action: 'adding_transaction',
    step: 'type',
    transaction: {}
  };

  const keyboard = {
    reply_markup: {
      inline_keyboard: [
        [
          { text: 'üí∞ Ingreso', callback_data: 'type_income' },
          { text: 'üí∏ Gasto', callback_data: 'type_expense' }
        ]
      ]
    }
  };

  await bot.sendMessage(chatId, "üí≠ ¬øQu√© tipo de transacci√≥n quieres agregar?", keyboard);
});

bot.onText(/\/eliminar/, async (msg) => {
  const chatId = msg.chat.id;
  
  await bot.sendMessage(chatId, `
üóëÔ∏è **Para eliminar una transacci√≥n:**

1. Usa /transacciones para ver las transacciones
2. Copia el ID de la transacci√≥n que quieres eliminar
3. Env√≠a: /eliminar_id [ID]

**Ejemplo:** \`/eliminar_id 12345678-1234-1234-1234-123456789abc\`
  `, { parse_mode: 'Markdown' });
});

bot.onText(/\/eliminar_id (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const transactionId = match[1].trim();

  try {
    const success = await deleteTransaction(transactionId);
    
    if (success) {
      await bot.sendMessage(chatId, "‚úÖ Transacci√≥n eliminada correctamente.");
    } else {
      await bot.sendMessage(chatId, "‚ùå No se pudo eliminar la transacci√≥n. Verifica que el ID sea correcto.");
    }
  } catch (error) {
    console.error('Error deleting transaction:', error);
    await bot.sendMessage(chatId, "‚ùå Error al eliminar la transacci√≥n. Int√©ntalo de nuevo.");
  }
});

bot.onText(/\/cancelar/, async (msg) => {
  const chatId = msg.chat.id;
  
  if (userStates[chatId]) {
    delete userStates[chatId];
    await bot.sendMessage(chatId, "‚ùå Operaci√≥n cancelada.");
  } else {
    await bot.sendMessage(chatId, "‚ÑπÔ∏è No hay ninguna operaci√≥n en curso.");
  }
});

// Manejo de callbacks (botones)
bot.on('callback_query', async (callbackQuery) => {
  const chatId = callbackQuery.message.chat.id;
  const data = callbackQuery.data;
  const messageId = callbackQuery.message.message_id;

  if (!userStates[chatId] || userStates[chatId].action !== 'adding_transaction') {
    await bot.answerCallbackQuery(callbackQuery.id, { text: "Sesi√≥n expirada. Usa /agregar para empezar de nuevo." });
    return;
  }

  const state = userStates[chatId];

  try {
    if (data.startsWith('type_')) {
      state.transaction.type = data.replace('type_', '');
      state.step = 'person';

      const couples = await getCouples();
      const couple = couples[0];

      const keyboard = {
        reply_markup: {
          inline_keyboard: [
            [
              { text: `üë§ ${couple.person1_name}`, callback_data: 'person_person1' },
              { text: `üë§ ${couple.person2_name}`, callback_data: 'person_person2' }
            ]
          ]
        }
      };

      await bot.editMessageText("üë§ ¬øQui√©n hace esta transacci√≥n?", {
        chat_id: chatId,
        message_id: messageId,
        reply_markup: keyboard.reply_markup
      });

    } else if (data.startsWith('person_')) {
      state.transaction.person = data.replace('person_', '');
      state.step = 'category';

      const categoryList = categories[state.transaction.type];
      const keyboard = {
        reply_markup: {
          inline_keyboard: categoryList.map(cat => [
            { text: cat.name, callback_data: `category_${cat.id}` }
          ])
        }
      };

      await bot.editMessageText("üìÇ Selecciona una categor√≠a:", {
        chat_id: chatId,
        message_id: messageId,
        reply_markup: keyboard.reply_markup
      });

    } else if (data.startsWith('category_')) {
      state.transaction.category = data.replace('category_', '');
      state.step = 'amount';

      await bot.editMessageText("üí∞ Env√≠a el monto de la transacci√≥n (solo n√∫meros):", {
        chat_id: chatId,
        message_id: messageId
      });
    }

    await bot.answerCallbackQuery(callbackQuery.id);
  } catch (error) {
    console.error('Error handling callback:', error);
    await bot.answerCallbackQuery(callbackQuery.id, { text: "Error procesando la selecci√≥n." });
  }
});

// Manejo de mensajes de texto
bot.on('message', async (msg) => {
  const chatId = msg.chat.id;
  const text = msg.text;

  // Ignorar comandos
  if (!text || text.startsWith('/')) return;

  const state = userStates[chatId];
  if (!state || state.action !== 'adding_transaction') return;

  try {
    if (state.step === 'amount') {
      const amount = parseFloat(text.replace(/[^\d.-]/g, ''));
      
      if (isNaN(amount) || amount <= 0) {
        await bot.sendMessage(chatId, "‚ùå Por favor env√≠a un monto v√°lido (solo n√∫meros).");
        return;
      }

      state.transaction.amount = amount;
      state.step = 'description';

      await bot.sendMessage(chatId, "üìù Env√≠a una descripci√≥n para la transacci√≥n:");

    } else if (state.step === 'description') {
      state.transaction.description = text;

      // Obtener datos de la pareja
      const couples = await getCouples();
      const couple = couples[0];

      // Crear la transacci√≥n
      const newTransaction = {
        couple_id: couple.id,
        amount: state.transaction.amount,
        description: state.transaction.description,
        category: state.transaction.category,
        type: state.transaction.type,
        person: state.transaction.person,
        transaction_date: new Date().toISOString().split('T')[0],
      };

      const result = await addTransaction(newTransaction);

      if (result) {
        const icon = result.type === "income" ? "üí∞" : "üí∏";
        const sign = result.type === "income" ? "+" : "-";
        const personName = result.person === "person1" ? couple.person1_name : couple.person2_name;
        const categoryName = getCategoryName(result.category, result.type);

        const successMessage = `
‚úÖ **Transacci√≥n agregada correctamente**

${icon} **${result.description}**
üíµ ${sign}${formatCurrency(result.amount)}
üìÇ ${categoryName}
üë§ ${personName}
üìÖ ${new Date(result.transaction_date).toLocaleDateString('es-ES')}

ID: \`${result.id}\`
        `;

        await bot.sendMessage(chatId, successMessage, { parse_mode: 'Markdown' });
      } else {
        await bot.sendMessage(chatId, "‚ùå Error al agregar la transacci√≥n. Int√©ntalo de nuevo.");
      }

      // Limpiar el estado
      delete userStates[chatId];
    }
  } catch (error) {
    console.error('Error processing message:', error);
    await bot.sendMessage(chatId, "‚ùå Error procesando el mensaje. Int√©ntalo de nuevo.");
  }
});

// Manejo de errores
bot.on('polling_error', (error) => {
  console.error('Polling error:', error);
});

console.log('ü§ñ Bot de Telegram iniciado correctamente');
console.log('üí° Token configurado:', token ? 'S√ç' : 'NO');
console.log('üì° Supabase configurado:', supabaseUrl ? 'S√ç' : 'NO');
